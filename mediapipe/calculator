import cv2
import mediapipe as mp
import time

# --- Inicializamos Mediapipe Hands ---
mp_hands = mp.solutions.hands
mp_drawing = mp.solutions.drawing_utils
hands = mp_hands.Hands(min_detection_confidence=0.5, min_tracking_confidence=0.5)

# --- Capturamos la cámara ---
cap = cv2.VideoCapture(0)

# --- Variables para lógica ---
last_finger_count = None        # Último número de dedos detectados
gesture_start_time = 0          # Tiempo en que comenzó ese gesto
numbers = []                    # Lista para guardar los números
operation = None                # Operación pendiente ("multiply")
result = None                   # Resultado de la operación

while True:
    # --- Leer un frame de la cámara ---
    ret, frame = cap.read()
    if not ret:
        break
    
    # --- Convertir BGR → RGB (Mediapipe usa RGB) ---
    image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    image.flags.writeable = False
    results = hands.process(image)  # Procesar con el modelo de manos
    image.flags.writeable = True
    image = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)  # Volver a BGR para OpenCV

    finger_count = 0  # Contador de dedos levantados

    # --- Si detecta manos ---
    if results.multi_hand_landmarks:
        for hand_landmarks in results.multi_hand_landmarks:
            tips_ids = [4, 8, 12, 16, 20]  # IDs de las puntas de los dedos
            fingers_up = []

            # Pulgar (comparar X porque se mueve de lado)
            if results.right_hand_landmark:
                if hand_landmarks.landmark[tips_ids[0]].x < hand_landmarks.landmark[tips_ids[0] - 1].x:
                    fingers_up.append(1)
            else:
                    if hand_landmarks.landmark[tips_ids[0]].x < hand_landmarks.landmark[tips_ids[0] - 1].x:
                        fingers_up.append(1)
                    else:
                        fingers_up.append(0)
            
            # Otros 4 dedos (comparar Y porque se mueven hacia arriba/abajo)
            for id in range(1, 5):
                if hand_landmarks.landmark[tips_ids[id]].y < hand_landmarks.landmark[tips_ids[id] - 2].y:
                    fingers_up.append(1)
                else:
                    fingers_up.append(0)

            # Contar dedos levantados
            finger_count = sum(fingers_up)

            # Dibujar la mano y conexiones
            mp_drawing.draw_landmarks(image, hand_landmarks, mp_hands.HAND_CONNECTIONS)

    # --- Detectar si la cantidad de dedos cambió ---
    if finger_count != last_finger_count:
        last_finger_count = finger_count
        gesture_start_time = time.time()
    
    else:
        # Si mantiene el mismo gesto 5 segundos
        if time.time() - gesture_start_time >= 5 and finger_count is not None:
            if finger_count == 0 and len(numbers) == 1:  # Puño cerrado después de 1 número
                operation = "multiply"
                gesture_start_time = time.time()
            elif finger_count > 0 and (len(numbers) < 2):
                numbers.append(finger_count)
                gesture_start_time = time.time()

    # --- Si ya tengo dos números y operación ---
    if len(numbers) == 2 and operation == "multiply":
        result = numbers[0] * numbers[1]
        numbers.clear()
        operation = None

    # --- Mostrar texto en pantalla ---
    cv2.putText(image, f"Dedos: {finger_count}", (30, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (0,255,0), 2)
    cv2.putText(image, f"Numeros: {numbers}", (30, 90), cv2.FONT_HERSHEY_SIMPLEX, 1, (255,255,0), 2)
    cv2.putText(image, f"Operacion: {operation}", (30, 130), cv2.FONT_HERSHEY_SIMPLEX, 1, (255,0,255), 2)
    if result is not None:
        cv2.putText(image, f"Resultado: {result}", (30, 170), cv2.FONT_HERSHEY_SIMPLEX, 1.2, (0,0,255), 3)

    # --- Mostrar imagen ---
    cv2.imshow("Calculadora con Gestos", image)

    # --- Salir con 'q' ---
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()

